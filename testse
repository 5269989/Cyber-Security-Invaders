import RPi.GPIO as GPIO
import time

# Define the GPIO pins connected to each segment and digit
SEGMENTS = {
    'a': 4, 'b': 18, 'c': 24, 'd': 23, 'e': 22, 'f': 17, 'g': 27
}
DIGITS = {
    1: 5,  # Assuming digit 1 is always on if using a single power rail
    2: 25, 3: 26, 4: 16
}

# Segment pattern for digits (0-9) where 1 = LED on, 0 = LED off for common anode
DIGIT_MAP = {
    0: (1, 1, 1, 1, 1, 1, 0),  # '0'
    1: (0, 1, 1, 0, 0, 0, 0),  # '1'
    2: (1, 1, 0, 1, 1, 0, 1),  # '2'
    3: (1, 1, 1, 1, 0, 0, 1),  # '3'
    4: (0, 1, 1, 0, 0, 1, 1),  # '4'
    5: (1, 0, 1, 1, 0, 1, 1),  # '5'
    6: (1, 0, 1, 1, 1, 1, 1),  # '6'
    7: (1, 1, 1, 0, 0, 0, 0),  # '7'
    8: (1, 1, 1, 1, 1, 1, 1),  # '8'
    9: (1, 1, 1, 1, 0, 1, 1)   # '9'
}

# Setup GPIO
def setup():
    GPIO.setmode(GPIO.BCM)  # Use BCM pin numbering
    for segment in SEGMENTS.values():
        GPIO.setup(segment, GPIO.OUT)
        GPIO.output(segment, GPIO.HIGH)  # Turn off all segments at start (HIGH for common anode)
    for digit in DIGITS.values():
        GPIO.setup(digit, GPIO.OUT)
        GPIO.output(digit, GPIO.HIGH)  # Turn off all digits at start (HIGH for common anode)

# Display a digit on a specific digit position
def display_digit_on_digit(digit_value, digit_position):
    if digit_value < 0 or digit_value > 9:
        return  # Only display 0-9
    
    segments = DIGIT_MAP[digit_value]
    for i, segment in enumerate(SEGMENTS.values()):
        GPIO.output(segment, GPIO.LOW if segments[i] else GPIO.HIGH)
    
    # Turn on the specific digit while others are off
    for d, pin in DIGITS.items():
        GPIO.output(pin, GPIO.LOW if d == digit_position else GPIO.HIGH)

# Main function
def main():
    try:
        setup()
        
        while True:
            number = 1234  # Example number to display
            digits = [int(d) for d in f"{number:04d}"]  # Convert number to list of digits
            
            for _ in range(1000):  # Show for a while, adjust as needed
                for i, digit in enumerate(digits, 1):
                    display_digit_on_digit(digit, i)
                    time.sleep(0.001)  # Very short delay for multiplexing, adjust for flicker

    except KeyboardInterrupt:
        print("\nProgram interrupted by user")
    finally:
        GPIO.cleanup()  # Clean up GPIO on exit

if __name__ == "__main__":
    main()
