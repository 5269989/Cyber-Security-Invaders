import RPi.GPIO as GPIO
import time

# GPIO setup
GPIO.setmode(GPIO.BCM)
GPIO.setwarnings(False)

# Define GPIO pins for segments
SEGMENTS = {
    'a': 4, 'b': 18, 'c': 24, 'd': 23, 'e': 22, 'f': 17, 'g': 27
}

# Define GPIO pins for digits
DIGITS = {
    1: 16, 2: 25, 3: 26, 4: 5
}

# Setup GPIO pins as outputs
for segment in SEGMENTS.values():
    GPIO.setup(segment, GPIO.OUT)
for digit in DIGITS.values():
    GPIO.setup(digit, GPIO.OUT)

# Define segment patterns for each digit
DIGIT_PATTERNS = {
    0: ('a', 'b', 'c', 'd', 'e', 'f'),
    1: ('b', 'c'),
    2: ('a', 'b', 'g', 'e', 'd'),
    3: ('a', 'b', 'g', 'c', 'd'),
    4: ('f', 'g', 'b', 'c'),
    5: ('a', 'f', 'g', 'c', 'd'),
    6: ('a', 'f', 'g', 'e', 'd', 'c'),
    7: ('a', 'b', 'c'),
    8: ('a', 'b', 'c', 'd', 'e', 'f', 'g'),
    9: ('a', 'b', 'c', 'f', 'g')
}

def display_digit(digit, number):
    # Turn on all segments for the digit
    for segment in DIGIT_PATTERNS.get(number, []):
        GPIO.output(SEGMENTS[segment], GPIO.HIGH)
    
    # Activate the specific digit
    GPIO.output(DIGITS[digit], GPIO.LOW)
    time.sleep(0.001)  # Brief display time
    GPIO.output(DIGITS[digit], GPIO.HIGH)

    # Turn off all segments
    for segment in SEGMENTS.values():
        GPIO.output(segment, GPIO.LOW)

def display_number(number):
    for i in range(4):
        digit = 4 - i  # Start from the leftmost digit
        display_digit(digit, int(number) % 10)
        number = number // 10

try:
    count = 9999
    while count >= 0:
        display_number(str(count).zfill(4))
        count -= 1
        time.sleep(0.5)  # Time between each count update

except KeyboardInterrupt:
    print("Countdown stopped by user.")

finally:
    GPIO.cleanup()  # Clean up GPIO on exit
