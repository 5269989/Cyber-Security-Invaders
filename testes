import RPi.GPIO as GPIO
import time

SEGMENTS = {
    'a': 4, 'b': 18, 'c': 24, 'd': 23, 'e': 22, 'f': 17, 'g': 27
}
DIGITS = {
    1: 16, 2: 25, 3: 26, 4: 5
}

def setup():
    GPIO.setwarnings(False)
    GPIO.setmode(GPIO.BCM)
    
    for segment in SEGMENTS.values():
        GPIO.setup(segment, GPIO.OUT)
        GPIO.output(segment, GPIO.HIGH)  # Turn off all segments (common anode)

    for digit in DIGITS.values():
        GPIO.setup(digit, GPIO.OUT)
        GPIO.output(digit, GPIO.HIGH)  # Turn off all digits initially

def get_segments_for_digit(digit):
    segment_map = {
        0: 'abcdef', 1: 'bc', 2: 'abdeg', 3: 'abcdg', 4: 'bcfg', 
        5: 'acdfg', 6: 'acdefg', 7: 'abc', 8: 'abcdefg', 9: 'abcdfg'
    }
    return segment_map.get(digit, '')

def display_number_on_7seg(number):
    if number < 0 or number > 9999:
        return  # Out of range for a 4-digit display
    
    digits = [int(d) for d in str(number).zfill(4)]
    
    for _ in range(200):  # Increase this for clearer visibility during testing
        for i, digit_value in enumerate(digits):
            digit_pin = DIGITS[i + 1]
            GPIO.output(digit_pin, GPIO.LOW)
            
            segments_on = get_segments_for_digit(digit_value)
            for segment, pin in SEGMENTS.items():
                GPIO.output(pin, GPIO.LOW if segment in segments_on else GPIO.HIGH)
            
            time.sleep(0.002)  # Slight increase for testing visibility
            GPIO.output(digit_pin, GPIO.HIGH)

def main():
    setup()
    try:
        for number in range(10000):  # From 0000 to 9999
            display_number_on_7seg(number)
            time.sleep(0.5)  # Hold each number for half a second for visibility
    except KeyboardInterrupt:
        pass
    finally:
        GPIO.cleanup()

if __name__ == '__main__':
    main()
